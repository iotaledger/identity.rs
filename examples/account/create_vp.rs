// Copyright 2020-2022 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

//! A Verifiable Presentation (VP) represents a bundle of one or more Verifiable Credentials.
//! This example demonstrates building and usage of VPs.
//!
//! cargo run --example account_create_vp

use identity::account::Account;
use identity::account::AccountBuilder;
use identity::account::IdentitySetup;
use identity::account::MethodContent;
use identity::core::json;
use identity::core::Duration;
use identity::core::FromJson;
use identity::core::Timestamp;
use identity::core::ToJson;
use identity::core::Url;
use identity::credential::Credential;
use identity::credential::CredentialBuilder;
use identity::credential::Presentation;
use identity::credential::PresentationBuilder;
use identity::credential::Subject;
use identity::crypto::ProofOptions;
use identity::did::verifiable::VerifierOptions;

use identity::account::Result;
use identity::iota::CredentialValidationOptions;
use identity::iota::FailFast;
use identity::iota::PresentationValidationOptions;

use identity::iota::Resolver;
use identity::iota::SubjectHolderRelationship;

#[tokio::main]
async fn main() -> Result<()> {
  // ===========================================================================
  // Step 1: Create identities for the issuer and the holder.
  // ===========================================================================

  // Create an account builder with in-memory storage for simplicity.
  // See `create_did` example to configure Stronghold storage.
  let mut builder: AccountBuilder = Account::builder();

  // Create an identity for the issuer.
  let mut issuer: Account = builder.create_identity(IdentitySetup::default()).await?;

  // Add a dedicated verification method to the issuer, with which to sign credentials.
  issuer
    .update_identity()
    .create_method()
    .content(MethodContent::GenerateEd25519)
    .fragment("issuerKey")
    .apply()
    .await?;

  // Create an identity for the holder, in this case also the subject.
  let mut alice: Account = builder.create_identity(IdentitySetup::default()).await?;

  // Add verification method to the holder.
  alice
    .update_identity()
    .create_method()
    .content(MethodContent::GenerateEd25519)
    .fragment("aliceKey")
    .apply()
    .await?;

  // ===========================================================================
  // Step 2: Issuer creates and signs a Verifiable Credential.
  // ===========================================================================

  // Create VC "subject" field containing subject ID and claims about it.
  let subject: Subject = Subject::from_json_value(json!({
    "id": alice.did().to_string(),
    "name": "Alice",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts",
    },
    "GPA": "4.0",
  }))?;

  // Build credential using subject above and issuer.
  let mut credential: Credential = CredentialBuilder::default()
    .id(Url::parse("https://example.edu/credentials/3732")?)
    .issuer(Url::parse(issuer.did().to_string())?)
    .type_("UniversityDegreeCredential")
    .subject(subject)
    .build()?;

  // Sign the Credential with the issuers default key.
  issuer
    .sign("#issuerKey", &mut credential, ProofOptions::default())
    .await?;

  println!("Credential JSON > {:#}", credential);

  // ===========================================================================
  // Step 3: Issuer sends the Verifiable Credential to the holder.
  // ===========================================================================

  // The credential is then serialized to JSON and transmitted to the holder in a secure manner.
  // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.
  let credential_json: String = credential.to_json()?;

  // ===========================================================================
  // Step 4: Verifier sends the holder a challenge and requests a signed Verifiable Presentation.
  // ===========================================================================

  // A unique random challenge generated by the requester per presentation can mitigate replay attacks
  let challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";

  // The verifier and holder also agree that the signature should have an expiry date
  // 10 minutes from now.
  let expires: Timestamp = Timestamp::now_utc().checked_add(Duration::minutes(10)).unwrap();

  // ===========================================================================
  // Step 5: Holder creates and signs a verifiable presentation from the issued credential.
  // ===========================================================================

  // Deserialize the credential.
  let credential: Credential = Credential::from_json(credential_json.as_str())?;

  // Create an unsigned Presentation from the previously issued Verifiable Credential.
  let mut presentation: Presentation = PresentationBuilder::default()
    .holder(Url::parse(alice.did().as_ref())?)
    .credential(credential)
    .build()?;

  // Sign the verifiable presentation using the holder's verification method
  // and include the requested challenge and expiry timestamp.
  alice
    .sign(
      "#aliceKey",
      &mut presentation,
      ProofOptions::new().challenge(challenge.to_string()).expires(expires),
    )
    .await?;

  // ===========================================================================
  // Step 6: Holder sends a verifiable presentation to the verifier.
  // ===========================================================================

  // Convert the Verifiable Presentation to JSON to send it to the verifier.
  let presentation_json: String = presentation.to_json()?;

  // ===========================================================================
  // Step 7: Verifier receives the Verifiable Presentation and verifies it.
  // ===========================================================================

  // Deserialize the presentation from the holder:
  let presentation: Presentation = Presentation::from_json(&presentation_json)?;

  // The verifier wants the following requirements to be satisfied:
  // - Signature verification (including checking the requested challenge to mitigate replay attacks)
  // - Presentation validation must fail if credentials expiring within the next 10 hours are encountered
  // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property
  // - The issuance date must not be in the future.

  let presentation_verifier_options: VerifierOptions = VerifierOptions::new()
    .challenge(challenge.to_owned())
    .allow_expired(false);

  // Do not allow credentials that expire within the next 10 hours.
  let credential_validation_options: CredentialValidationOptions = CredentialValidationOptions::default()
    .earliest_expiry_date(Timestamp::now_utc().checked_add(Duration::hours(10)).unwrap());

  let presentation_validation_options = PresentationValidationOptions::default()
    .presentation_verifier_options(presentation_verifier_options.clone())
    .shared_validation_options(credential_validation_options)
    .subject_holder_relationship(SubjectHolderRelationship::AlwaysSubject);

  // Validate the presentation and all the credentials included in it.
  let resolver: Resolver = Resolver::new().await?;
  resolver
    .verify_presentation(
      &presentation,
      &presentation_validation_options,
      FailFast::FirstError,
      None,
      None,
    )
    .await?;

  // Since no errors were thrown by `verify_presentation` we know that the validation was successful.
  println!("VP successfully validated");

  // Note that we did not declare a latest allowed issuance date for credentials. This is because we only want to check
  // that the credentials do not have an issuance date in the future which is a default check.

  Ok(())
}
